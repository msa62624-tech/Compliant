// This is your Prisma schema file
// Learn more: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// ORIGINAL ARCHITECTURE (from commit c1e9958)
// ============================================

model User {
  id                     String    @id @default(uuid())
  email                  String    @unique
  password               String
  firstName              String
  lastName               String
  role                   UserRole  @default(USER)
  isActive               Boolean   @default(true)
  createdAt              DateTime  @default(now())
  updatedAt              DateTime  @updatedAt

  contractorsCreated    Contractor[]   @relation("ContractorCreator")
  projects              Project[]
  generatedCOIsAssigned GeneratedCOI[] @relation("AssignedAdmin")
  auditLogs             AuditLog[]
  refreshTokens         RefreshToken[]

  @@map("users")
}

// Separate table for refresh tokens - prevents timing attacks and DoS
// Uses selector/verifier pattern for O(1) lookup with single bcrypt comparison
model RefreshToken {
  id          String   @id @default(uuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  selector    String   @unique // Unique constraint creates index automatically
  verifier    String   // Hashed with bcrypt (for secure comparison)
  expiresAt   DateTime
  createdAt   DateTime @default(now())

  @@index([userId, expiresAt]) // Composite index for user-specific and cleanup operations
  @@map("refresh_tokens")
}

enum UserRole {
  SUPER_ADMIN // Full access, sees everything, no filtering
  ADMIN // Assistant admin, filtered by assigned_admin_email
  MANAGER
  USER
  CONTRACTOR
  SUBCONTRACTOR
  BROKER
}

model Contractor {
  id              String           @id @default(uuid())
  name            String
  email           String           @unique
  phone           String?
  company         String?
  contractorType  ContractorType   @default(SUBCONTRACTOR)
  status          ContractorStatus @default(PENDING)
  insuranceStatus InsuranceStatus  @default(PENDING)

  // Broker information
  brokerName    String?
  brokerEmail   String?
  brokerPhone   String?
  brokerCompany String?
  brokerType    BrokerType?

  // Per-policy broker fields
  brokerGlName        String?
  brokerGlEmail       String?
  brokerGlPhone       String?
  brokerAutoName      String?
  brokerAutoEmail     String?
  brokerAutoPhone     String?
  brokerUmbrellaName  String?
  brokerUmbrellaEmail String?
  brokerUmbrellaPhone String?
  brokerWcName        String?
  brokerWcEmail       String?
  brokerWcPhone       String?

  // Admin assignment (for assistant admin filtering)
  assignedAdminEmail String?

  createdById String
  createdBy   User     @relation("ContractorCreator", fields: [createdById], references: [id], onDelete: Cascade)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  insuranceDocuments    InsuranceDocument[]
  projectContractors    ProjectContractor[]
  generatedCOIs         GeneratedCOI[]
  projectSubcontractors ProjectSubcontractor[]

  @@map("contractors")
}

enum ContractorType {
  GENERAL_CONTRACTOR
  SUBCONTRACTOR
}

enum BrokerType {
  GLOBAL
  PER_POLICY
}

enum ContractorStatus {
  ACTIVE
  INACTIVE
  PENDING
  SUSPENDED
}

enum InsuranceStatus {
  COMPLIANT
  NON_COMPLIANT
  PENDING
  EXPIRED
}

model Project {
  id          String        @id @default(uuid())
  name        String
  description String?
  address     String? // Project location/address
  startDate   DateTime
  endDate     DateTime?
  status      ProjectStatus @default(PLANNING)
  gcName      String?
  location    String?

  // ACRIS Data Fields
  borough             String?
  block               String?
  lot                 String?
  buildingHeight      String?
  structureType       String?
  entity              String?
  additionalInsureds  String?
  contactPerson       String?
  contactEmail        String?
  contactPhone        String?

  // Admin assignment (for assistant admin filtering)
  assignedAdminEmail String?

  createdById String
  createdBy   User     @relation(fields: [createdById], references: [id], onDelete: Cascade)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  projectContractors    ProjectContractor[]
  projectSubcontractors ProjectSubcontractor[]
  generatedCOIs         GeneratedCOI[]

  @@map("projects")
}

enum ProjectStatus {
  PLANNING
  ACTIVE
  ON_HOLD
  COMPLETED
  CANCELLED
}

model ProjectContractor {
  id           String     @id @default(uuid())
  projectId    String
  project      Project    @relation(fields: [projectId], references: [id], onDelete: Cascade)
  contractorId String
  contractor   Contractor @relation(fields: [contractorId], references: [id], onDelete: Cascade)
  role         String?
  assignedAt   DateTime   @default(now())

  @@unique([projectId, contractorId])
  @@map("project_contractors")
}

// Junction table for Project <-> Subcontractor
model ProjectSubcontractor {
  id              String     @id @default(uuid())
  projectId       String
  project         Project    @relation(fields: [projectId], references: [id], onDelete: Cascade)
  subcontractorId String
  subcontractor   Contractor @relation(fields: [subcontractorId], references: [id], onDelete: Cascade)
  role            String?
  assignedAt      DateTime   @default(now())

  @@unique([projectId, subcontractorId])
  @@map("project_subcontractors")
}

// Generated COI (Certificate of Insurance) - Core of the workflow
// Generated COI (Certificate of Insurance) Model
model GeneratedCOI {
  id              String     @id @default(uuid())
  projectId       String
  project         Project    @relation(fields: [projectId], references: [id], onDelete: Cascade)
  subcontractorId String
  subcontractor   Contractor @relation(fields: [subcontractorId], references: [id], onDelete: Cascade)

  projectName       String?
  gcName            String?
  subcontractorName String?

  status COIStatus @default(AWAITING_BROKER_INFO)

  // Broker information
  brokerName    String?
  brokerEmail   String?
  brokerPhone   String?
  brokerCompany String?

  // Per-policy broker info
  brokerGlName        String?
  brokerGlEmail       String?
  brokerGlPhone       String?
  brokerAutoName      String?
  brokerAutoEmail     String?
  brokerAutoPhone     String?
  brokerUmbrellaName  String?
  brokerUmbrellaEmail String?
  brokerUmbrellaPhone String?
  brokerWcName        String?
  brokerWcEmail       String?
  brokerWcPhone       String?

  // Policy documents
  glPolicyUrl       String?
  umbrellaPolicyUrl String?
  autoPolicyUrl     String?
  wcPolicyUrl       String?

  // Broker signatures
  glBrokerSignatureUrl       String?
  umbrellaBrokerSignatureUrl String?
  autoBrokerSignatureUrl     String?
  wcBrokerSignatureUrl       String?

  // Policy details
  glExpirationDate       DateTime?
  umbrellaExpirationDate DateTime?
  autoExpirationDate     DateTime?
  wcExpirationDate       DateTime?

  // First COI tracking
  firstCOIUploaded Boolean @default(false)
  firstCOIUrl      String?

  // Admin review
  assignedAdminEmail String?
  assignedAdmin      User?   @relation("AssignedAdmin", fields: [assignedAdminEmail], references: [email], onDelete: SetNull)
  deficiencyNotes    String?
  rejectionReason    String?

  // Timestamps
  uploadedForReviewDate   DateTime?
  brokerVerifiedAtRenewal Boolean   @default(false)
  createdAt               DateTime  @default(now())
  updatedAt               DateTime  @updatedAt

  @@index([projectId])
  @@index([subcontractorId])
  @@index([status])
  @@index([assignedAdminEmail])
  @@map("generated_cois")
}

enum COIStatus {
  AWAITING_BROKER_INFO
  AWAITING_BROKER_UPLOAD
  AWAITING_BROKER_SIGNATURE
  AWAITING_ADMIN_REVIEW
  ACTIVE
  DEFICIENCY_PENDING
  EXPIRED
}

// Insurance Document Model
model InsuranceDocument {
  id             String         @id @default(uuid())
  contractorId   String
  contractor     Contractor     @relation(fields: [contractorId], references: [id], onDelete: Cascade)
  type           InsuranceType
  provider       String
  policyNumber   String
  coverageAmount Float
  effectiveDate  DateTime
  expirationDate DateTime
  status         DocumentStatus @default(PENDING)
  fileUrl        String?
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt

  @@index([contractorId])
  @@index([status])
  @@index([expirationDate])
  @@map("insurance_documents")
}

enum InsuranceType {
  GENERAL_LIABILITY
  WORKERS_COMPENSATION
  AUTO_LIABILITY
  PROFESSIONAL_LIABILITY
  UMBRELLA
}

enum DocumentStatus {
  PENDING
  VERIFIED
  REJECTED
  EXPIRED
}

// Audit Log Model for security and compliance tracking
model AuditLog {
  id         String   @id @default(uuid())
  userId     String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  action     String   // CREATE, UPDATE, DELETE, LOGIN, LOGOUT, VIEW, etc.
  resource   String   // USER, CONTRACTOR, PROJECT, INSURANCE_DOCUMENT, etc.
  resourceId String?  // ID of the affected resource
  changes    Json?    // JSON object with before/after values for updates
  metadata   Json?    // Additional context (e.g., request headers, IP, etc.)
  ipAddress  String?
  userAgent  String?
  timestamp  DateTime @default(now())

  @@index([userId])
  @@index([resource, resourceId])
  @@index([timestamp])
  @@index([action])
  @@map("audit_logs")
}
